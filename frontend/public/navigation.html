<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>AR Navigation with Arrow Markers</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
        background: #000;
        height: 100vh;
        width: 100vw;
        position: relative;
      }

      .arjs-loader {
        height: 100%;
        width: 100%;
        position: absolute;
        top: 0;
        background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
        z-index: 9999;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        color: white;
        transition: all 0.5s ease;
      }

      .arjs-loader h1 {
        font-size: 1.8em;
        margin-bottom: 15px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .arjs-loader div {
        text-align: center;
        font-size: 1em;
        margin: 8px 0;
        padding: 8px 16px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        backdrop-filter: blur(10px);
        max-width: 90%;
      }

      .spinner {
        width: 30px;
        height: 30px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 15px auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      #scene {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
      }

      #ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 100;
        pointer-events: none;
        transition: opacity 0.5s ease;
      }

      .ui-panel {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.85);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        color: white;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
      }

      #status-panel {
        position: absolute;
        top: 15px;
        left: 15px;
        right: 15px;
        padding: 15px;
        text-align: center;
      }

      #controls-panel {
        position: absolute;
        bottom: 15px;
        left: 15px;
        right: 15px;
        padding: 15px;
      }

      #distance-display {
        font-size: 1.6em;
        font-weight: bold;
        color: #4caf50;
        margin-bottom: 8px;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        margin-top: 80px;
      }

      #direction-display {
        font-size: 1.1em;
        color: #ffc107;
        margin: 8px 0;
        font-weight: 600;
      }

      #instruction-display {
        font-size: 0.95em;
        color: #e0e0e0;
        margin: 8px 0;
      }

      #gps-info {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        margin-top: 10px;
        font-size: 0.85em;
      }

      .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        animation: pulse 2s infinite;
      }

      .status-excellent {
        background: #4caf50;
      }
      .status-good {
        background: #8bc34a;
      }
      .status-moderate {
        background: #ffc107;
      }
      .status-poor {
        background: #ff5722;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      #destination-select {
        width: 100%;
        padding: 12px;
        margin-bottom: 12px;
        border: none;
        border-radius: 10px;
        font-size: 15px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        backdrop-filter: blur(10px);
      }

      #destination-select option {
        background: #333;
        color: white;
      }

      .action-button {
        width: 100%;
        padding: 14px;
        border: none;
        border-radius: 10px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 6px 0;
        text-transform: uppercase;
        letter-spacing: 0.8px;
      }

      #navigate-btn {
        background: linear-gradient(135deg, #4caf50, #45a049);
        color: white;
      }

      #navigate-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      }

      #navigate-btn:disabled {
        background: #666;
        cursor: not-allowed;
        transform: none;
      }

      #stop-btn {
        background: linear-gradient(135deg, #f44336, #d32f2f);
        color: white;
      }

      #calibrate-btn {
        background: linear-gradient(135deg, #2196f3, #1976d2);
        color: white;
        width: auto;
        padding: 8px 16px;
        font-size: 13px;
      }

      .hidden {
        display: none !important;
      }

      #compass {
        position: fixed;
        top: 50%;
        right: 15px;
        transform: translateY(-50%);
        width: 70px;
        height: 70px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 22px;
        color: #4caf50;
        backdrop-filter: blur(10px);
      }

      #compass-needle {
        position: absolute;
        width: 2px;
        height: 25px;
        background: #ff5722;
        transform-origin: bottom center;
        transition: transform 0.3s ease;
      }

      .ar-arrow {
        position: absolute;
        transform-origin: center bottom;
        animation: pulseArrow 1.5s infinite alternate;
      }

      @keyframes bounce {
        0%,
        20%,
        50%,
        80%,
        100% {
          transform: translateY(0);
        }
        40% {
          transform: translateY(-8px);
        }
        60% {
          transform: translateY(-4px);
        }
      }

      #map-overlay {
        position: absolute;
        top: 80px;
        left: 15px;
        width: 300px;
        height: 300px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 15px;
        z-index: 15;
        padding: 15px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
      }

      #map-title {
        color: white;
        margin-bottom: 10px;
        text-align: center;
        font-weight: bold;
      }

      #campus-map {
        flex: 1;
        border-radius: 10px;
        position: relative;
        overflow: hidden;
      }

      /* Map elements */
      .map-node {
        position: absolute;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #4caf50;
        transform: translate(-50%, -50%);
        border: 2px solid white;
        z-index: 2;
      }

      .map-path {
        position: absolute;
        height: 4px;
        background: #ffc107;
        transform-origin: left center;
        z-index: 1;
      }

      .map-user {
        position: absolute;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #2196f3;
        transform: translate(-50%, -50%);
        border: 2px solid white;
        z-index: 3;
        box-shadow: 0 0 10px #2196f3;
      }

      .map-destination {
        position: absolute;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #f44336;
        transform: translate(-50%, -50%);
        border: 2px solid white;
        z-index: 3;
        box-shadow: 0 0 10px #f44336;
      }

      .map-route {
        position: absolute;
        height: 4px;
        background: #4caf50;
        transform-origin: left center;
        z-index: 1;
      }

      .map-label {
        position: absolute;
        color: white;
        font-size: 10px;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 5px;
        border-radius: 4px;
        white-space: nowrap;
        z-index: 4;
      }

      #camera-container {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 150px;
        height: 100px;
        border-radius: 10px;
        overflow: hidden;
        z-index: 15;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.2);
        transition: all 0.5s ease;
      }

      #camera-container.full-screen {
        position: relative;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 0;
        border: none;
        z-index: -9999;
      }

      #camera-feed {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      #debug-panel {
        position: absolute;
        bottom: 200px;
        left: 15px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 8px;
        font-size: 12px;
        max-width: 300px;
        z-index: 20;
        display: none;
      }

      #map-toggle {
        position: absolute;
        top: 15px;
        left: 15px;
        z-index: 20;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 5px;
        padding: 8px 12px;
        color: white;
        cursor: pointer;
        transition: all 0.3s;
        pointer-events: auto;
        font-size: 0.9em;
      }

      #map-toggle:hover {
        background: rgba(0, 0, 0, 0.9);
      }

      #show-ui-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        z-index: 20;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 5px;
        padding: 8px 12px;
        color: white;
        cursor: pointer;
        transition: all 0.3s;
        pointer-events: auto;
        font-size: 0.9em;
      }

      #show-ui-btn:hover {
        background: rgba(0, 0, 0, 0.9);
      }

      /* FIXED: Navigation state UI visibility rules */
      body.navigation-active
        #ui-overlay
        > *:not(#camera-container):not(#compass):not(#show-ui-btn):not(
          #map-overlay
        ):not(#map-toggle) {
        opacity: 0.3;
        pointer-events: none;
      }

      /* FIXED: When UI is visible during navigation, show all elements with higher specificity */
      body.navigation-active.ui-visible #ui-overlay > * {
        opacity: 1 !important;
        pointer-events: auto !important;
      }

      /* FIXED: But keep camera in full-screen mode when UI is visible */
      body.navigation-active.ui-visible #camera-container.full-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -9999;
      }

      /* Leaflet map adjustments */
      .leaflet-container {
        background: #1e3c72;
      }
      .leaflet-control-attribution {
        background: rgba(0, 0, 0, 0.7);
        color: white;
        font-size: 9px;
      }
      .leaflet-popup-content-wrapper {
        background: rgba(0, 0, 0, 0.85);
        color: white;
        border-radius: 8px;
      }
      .leaflet-popup-tip {
        background: rgba(0, 0, 0, 0.85);
      }

      /* Arrow styling for AR markers */
      .arrow-marker {
        animation: pulseArrow 1.5s infinite alternate;
      }

      @keyframes pulseArrow {
        0% {
          opacity: 0.7;
          transform: scale(1);
        }
        100% {
          opacity: 1;
          transform: scale(1.1);
        }
      }

      .arrow-head {
        width: 0;
        height: 0;
        border-left: 15px solid transparent;
        border-right: 15px solid transparent;
        border-bottom: 30px solid #4caf50;
        position: relative;
        transform-style: preserve-3d;
      }

      .arrow-shaft {
        width: 8px;
        height: 50px;
        background: #4caf50;
        position: absolute;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
      }

      .direction-text {
        position: absolute;
        top: -1.5rem;
        left: -0.5rem;
        color: white;
        font-size: 0.8rem;
        background: rgba(0, 0, 0, 0.6);
        padding: 0.1rem 0.3rem;
        border-radius: 0.2rem;
        white-space: nowrap;
      }

      #indoor-prompt-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .modal-content {
        background: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      .modal-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 25px;
      }

      .modal-btn {
        padding: 12px 25px;
        border-radius: 50px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s;
        border: none;
      }

      #indoor-yes {
        background: #4caf50;
        color: white;
      }

      #indoor-no {
        background: #f1f1f1;
        color: #333;
      }

      .modal-btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }
    </style>
  </head>
  <body>
    <div class="arjs-loader">
      <h1>üß≠</h1>
      <h1>Campus AR Path</h1>
      <h1>Navigator</h1>
      <div class="spinner"></div>
      <div id="loading-status">Initializing navigation system...</div>
      <div id="permission-status">Requesting location permissions...</div>
    </div>

    <!-- Fixed AR scene configuration -->
    <a-scene
      id="scene"
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; debugUIEnabled: true; 
        detectionMode: mono; matrixCodeType: 3x3; 
        trackingMethod: best; sourceWidth: 1280; 
        sourceHeight: 720; displayWidth: 1280; 
        videoTexture: true;
        displayHeight: 720;"
      renderer="logarithmicDepthBuffer: true; precision: medium; antialias: true;"
      camera="fov: 60;"
    >
      <a-camera
        gps-camera="gpsMinDistance: 1; gpsTimeInterval: 500;"
        rotation-reader
      ></a-camera>

      <!-- Test marker at known position -->
      <a-entity
        id="test-marker"
        gps-entity-place="latitude: 21.289019; longitude: 81.700296"
        visible="true"
      >
        <a-entity
          gltf-model="./assets/arrow.glb"
          scale="1 1 1"
          rotation="-90 0 0"
          position="0 0 0"
        ></a-entity>
      </a-entity>
    </a-scene>
    <div id="ui-overlay">
      <button id="map-toggle">Show Campus Map</button>
      <button id="show-ui-btn">Show UI</button>

      <div id="camera-container" class="hidden">
        <video id="camera-feed" autoplay muted playsinline></video>
      </div>

      <div id="status-panel" class="ui-panel hidden">
        <div id="distance-display">Select Destination</div>
        <div id="direction-display"></div>
        <div id="instruction-display">Choose where you want to navigate</div>
        <div id="gps-info">
          <span class="status-dot status-poor"></span>
          <span id="gps-status-text">Acquiring GPS signal...</span>
        </div>
      </div>

      <div id="controls-panel" class="ui-panel hidden">
        <select id="destination-select">
          <option value="">üéØ Select Destination</option>
          <option value="main_gate">üìö Main Gate</option>
          <option value="library">üìñ Library</option>
          <option value="cafeteria">üçî Cafeteria</option>
          <option value="gym">üèãÔ∏è‚Äç‚ôÇÔ∏è Gym</option>
          <option value="auditorium">üé≠ Auditorium</option>
        </select>

        <button id="navigate-btn" class="action-button" disabled>
          Start Navigation
        </button>

        <button id="stop-btn" class="action-button hidden">
          Stop Navigation
        </button>

        <button id="calibrate-btn" class="action-button">
          üì± Calibrate Compass
        </button>
      </div>

      <div id="compass" class="hidden">
        <div id="compass-needle"></div>
        <span>N</span>
      </div>

      <div id="map-overlay" class="hidden">
        <div id="map-title">Campus Map</div>
        <div id="campus-map"></div>
      </div>

      <div id="debug-panel">
        <div><strong>Debug Information</strong></div>
        <div id="debug-info">Loading...</div>
      </div>
    </div>

    <div id="indoor-prompt-modal">
      <div class="modal-content">
        <h2>You've Arrived at the Building!</h2>
        <p>Would you like indoor navigation to a specific room?</p>
        <div class="modal-buttons">
          <button id="indoor-yes" class="modal-btn">
            Yes, Show Indoor Navigation
          </button>
          <button id="indoor-no" class="modal-btn">No, I'm Done</button>
        </div>
      </div>
    </div>

    <script>
      let CAMPUS_NODES = {};
      let CAMPUS_PATHS = [];
      let DESTINATIONS = {};
      let campusMap = null; // Leaflet map instance

      // Category to icon mapping
      const CATEGORY_ICONS = {
        building: "üè¢",
        entrance: "üö™",
        parking: "üÖøÔ∏è",
        landmark: "üìç",
        facility: "üèóÔ∏è",
        emergency: "üÜò",
        library: "üìö",
        cafeteria: "üçî",
        gym: "üèãÔ∏è‚Äç‚ôÇÔ∏è",
        auditorium: "üé≠",
        main_gate: "üèõÔ∏è",
        classroom: "üìù",
        office: "üíº",
        lab: "üî¨",
        toilet: "üöª",
        garden: "üå≥",
      };
      let userPosition = {
        lat: 21.28912,
        lng: 81.700358,
        accuracy: 5,
        heading: 0,
        speed: 0,
      };

      let userHeading = 0;
      let selectedDestination = null;
      let isNavigating = false;
      let arMarkers = [];
      let gpsAccuracy = Infinity;
      let compassCalibrated = false;
      let lastUpdate = 0;
      let watchId = null;
      let simulationMode = false;
      let currentRoute = [];
      let pathArrows = [];
      let cameraStream = null;
      let uiVisible = true;
      let announcedNodes = new Set();
      let lastAnnouncedNode = null;
      let lastAnnouncementTime = 0;
      let arrivedAtBuilding = false;
      let currentBuildingName = "";
      const indoorPromptModal = document.getElementById("indoor-prompt-modal");
      let destinationNode = null;

      const elements = {
        loader: document.querySelector(".arjs-loader"),
        loadingStatus: document.getElementById("loading-status"),
        permissionStatus: document.getElementById("permission-status"),
        statusPanel: document.getElementById("status-panel"),
        controlsPanel: document.getElementById("controls-panel"),
        compass: document.getElementById("compass"),
        compassNeedle: document.getElementById("compass-needle"),
        mapOverlay: document.getElementById("map-overlay"),
        mapToggle: document.getElementById("map-toggle"),
        campusMap: document.getElementById("campus-map"),
        cameraFeed: document.getElementById("camera-feed"),
        debugPanel: document.getElementById("debug-panel"),
        debugInfo: document.getElementById("debug-info"),
        destinationSelect: document.getElementById("destination-select"),
        navigateBtn: document.getElementById("navigate-btn"),
        stopBtn: document.getElementById("stop-btn"),
        calibrateBtn: document.getElementById("calibrate-btn"),
        distanceDisplay: document.getElementById("distance-display"),
        directionDisplay: document.getElementById("direction-display"),
        instructionDisplay: document.getElementById("instruction-display"),
        gpsStatusText: document.getElementById("gps-status-text"),
        statusDot: document.querySelector(".status-dot"),
        scene: document.getElementById("scene"),
        showUiBtn: document.getElementById("show-ui-btn"),
        indoorYes: document.getElementById("indoor-yes"),
        indoorNo: document.getElementById("indoor-no"),
      };

      function calculateDistance(lat1, lng1, lat2, lng2) {
        const R = 6371000;
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLng / 2) *
            Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function calculateBearing(lat1, lng1, lat2, lng2) {
        const R = 6371; // Earth radius in km
        const dLng = ((lng2 - lng1) * Math.PI) / 180;
        const lat1Rad = (lat1 * Math.PI) / 180;
        const lat2Rad = (lat2 * Math.PI) / 180;

        const y = Math.sin(dLng) * Math.cos(lat2Rad);
        const x =
          Math.cos(lat1Rad) * Math.sin(lat2Rad) -
          Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);

        const bearing = Math.atan2(y, x);
        return ((bearing * 180) / Math.PI + 360) % 360;
      }

      function bearingToDirection(bearing, userHeading) {
        // Calculate the difference between bearing and user heading
        let diff = bearing - userHeading;
        // Normalize to -180 to 180 range
        diff = (((diff % 360) + 540) % 360) - 180;

        if (Math.abs(diff) <= 15) {
          return "Keep Moving Straight";
        } else if (diff > 15 && diff <= 75) {
          return "Turn Slightly Right";
        } else if (diff > 75 && diff <= 105) {
          return "Turn Right";
        } else if (diff > 105 && diff <= 165) {
          return "Turn Sharp Right";
        } else if (diff > 165 || diff <= -165) {
          return "Turn Around";
        } else if (diff < -15 && diff >= -75) {
          return "Turn Slightly Left";
        } else if (diff < -75 && diff >= -105) {
          return "Turn Left";
        } else if (diff < -105 && diff >= -165) {
          return "Turn Sharp Left";
        }
        return "continue";
      }

      function findNearestNode(lat, lng) {
        let minDistance = Infinity;
        let nearestNode = null;

        for (const [id, node] of Object.entries(CAMPUS_NODES)) {
          const distance = calculateDistance(lat, lng, node.lat, node.lng);
          if (distance < minDistance) {
            minDistance = distance;
            nearestNode = { id, ...node };
          }
        }

        return nearestNode;
      }

      function findShortestPath(startNodeId, endNodeId) {
        const graph = {};

        for (const nodeId in CAMPUS_NODES) {
          graph[nodeId] = [];
        }

        for (const path of CAMPUS_PATHS) {
          graph[path.from].push({ node: path.to, distance: path.distance });
          graph[path.to].push({ node: path.from, distance: path.distance });
        }

        const distances = {};
        const previous = {};
        const queue = [];

        for (const nodeId in graph) {
          if (nodeId === startNodeId) {
            distances[nodeId] = 0;
          } else {
            distances[nodeId] = Infinity;
          }
          previous[nodeId] = null;
          queue.push(nodeId);
        }

        while (queue.length > 0) {
          let minNode = null;
          for (const nodeId of queue) {
            if (minNode === null || distances[nodeId] < distances[minNode]) {
              minNode = nodeId;
            }
          }

          queue.splice(queue.indexOf(minNode), 1);

          if (minNode === endNodeId) {
            break;
          }

          for (const neighbor of graph[minNode]) {
            const alt = distances[minNode] + neighbor.distance;
            if (alt < distances[neighbor.node]) {
              distances[neighbor.node] = alt;
              previous[neighbor.node] = minNode;
            }
          }
        }

        const path = [];
        let current = endNodeId;
        while (current !== null) {
          path.unshift(current);
          current = previous[current];
        }

        return path;
      }

      function calculateRoute() {
        if (!userPosition || !selectedDestination) return [];

        const startNode = findNearestNode(userPosition.lat, userPosition.lng);
        const endNodeId = DESTINATIONS[selectedDestination].node;

        return findShortestPath(startNode.id, endNodeId);
      }

      // NEW: Create arrow marker at position with specified direction
      function createDynamicArrow(
        lat,
        lng,
        bearing,
        height = 1.5,
        isNode = false
      ) {
        const arrow = document.createElement("a-entity");
        arrow.classList.add("ar-arrow");
        arrow.setAttribute("gps-entity-place", {
          latitude: lat,
          longitude: lng,
          altitude: height,
        });

        // Create arrow with dynamic orientation
        const arrowContainer = document.createElement("a-entity");
        arrowContainer.setAttribute("rotation", `0 ${bearing} 0`);

        const arrowHead = document.createElement("a-entity");
        arrowHead.classList.add("arrow-head");
        arrowHead.setAttribute(
          "geometry",
          "primitive: cone; radiusBottom: 0.5; radiusTop: 0; height: 1"
        );
        arrowHead.setAttribute(
          "material",
          "color: #4CAF50; metalness: 0.5; roughness: 0.3"
        );
        arrowHead.setAttribute("position", "0 0.75 0");

        const arrowShaft = document.createElement("a-entity");
        arrowShaft.classList.add("arrow-shaft");
        arrowShaft.setAttribute(
          "geometry",
          "primitive: cylinder; radius: 0.1; height: 1.5"
        );
        arrowShaft.setAttribute("material", "color: #4CAF50");
        arrowShaft.setAttribute("position", "0 0 0");

        arrowContainer.appendChild(arrowHead);
        arrowContainer.appendChild(arrowShaft);
        arrow.appendChild(arrowContainer);

        // Add pulsing animation
        arrow.setAttribute("animation", {
          property: "scale",
          dir: "alternate",
          dur: 1000,
          loop: true,
          from: "1 1 1",
          to: "1.1 1.1 1.1",
        });

        elements.scene.appendChild(arrow);
        pathArrows.push(arrow);
        return arrow;
      }

      function createPathArrows() {
        clearPathArrows();

        if (!currentRoute.length) return;

        // Create arrows for each segment of the route
        for (let i = 0; i < currentRoute.length - 1; i++) {
          const fromNodeId = currentRoute[i];
          const toNodeId = currentRoute[i + 1];

          const fromNode = CAMPUS_NODES[fromNodeId];
          const toNode = CAMPUS_NODES[toNodeId];

          if (!fromNode || !toNode) continue;

          // Calculate bearing to next node
          const bearing = calculateBearing(
            fromNode.lat,
            fromNode.lng,
            toNode.lat,
            toNode.lng
          );

          // Create arrow at node pointing to next node
          createDynamicArrow(fromNode.lat, fromNode.lng, bearing, 1.5, true);

          // Create intermediate arrows along the path
          const distance = calculateDistance(
            fromNode.lat,
            fromNode.lng,
            toNode.lat,
            toNode.lng
          );

          if (distance > 20) {
            const numArrows = Math.min(Math.floor(distance / 20), 3);
            for (let j = 1; j <= numArrows; j++) {
              const progress = j / (numArrows + 1);
              const interLat =
                fromNode.lat + (toNode.lat - fromNode.lat) * progress;
              const interLng =
                fromNode.lng + (toNode.lng - fromNode.lng) * progress;

              // Arrow points to the next node
              createDynamicArrow(interLat, interLng, bearing, 1.0, false);
            }
          }
        }

        // Create arrow at the destination
        const destinationId = currentRoute[currentRoute.length - 1];
        const destinationNode = CAMPUS_NODES[destinationId];
        if (destinationNode) {
          createDynamicArrow(
            destinationNode.lat,
            destinationNode.lng,
            0, // Facing north at destination
            1.5,
            true
          );
        }
      }

      function clearPathArrows() {
        pathArrows.forEach((arrow) => {
          if (arrow.parentNode === elements.scene) {
            elements.scene.removeChild(arrow);
          }
        });
        pathArrows = [];
      }

      function initLeafletMap() {
        // Initialize the Leaflet map if it hasn't been created yet
        if (!campusMap) {
          campusMap = L.map("campus-map", {
            attributionControl: false,
          }).setView([21.28912, 81.700358], 17);

          // Add OpenStreetMap layer
          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution:
              '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
          }).addTo(campusMap);

          // Add attribution to bottom right
          L.control
            .attribution({
              prefix: false,
              position: "bottomright",
            })
            .addTo(campusMap);
        }
      }

      function speak(text) {
        if ("speechSynthesis" in window) {
          const utterance = new SpeechSynthesisUtterance(text);
          utterance.volume = 1;
          utterance.rate = 1;
          utterance.pitch = 1;
          window.speechSynthesis.speak(utterance);
        }
      }

      function getTurnDirection(prevNode, currentNode, nextNode) {
        if (!prevNode || !nextNode) return "keep moving straight";

        const bearingToCurrent = calculateBearing(
          prevNode.lat,
          prevNode.lng,
          currentNode.lat,
          currentNode.lng
        );

        const bearingToNext = calculateBearing(
          currentNode.lat,
          currentNode.lng,
          nextNode.lat,
          nextNode.lng
        );

        const angleDiff = (bearingToNext - bearingToCurrent + 360) % 360;

        if (angleDiff > 337.5 || angleDiff < 22.5)
          return "keep moving straight";
        if (angleDiff >= 22.5 && angleDiff < 67.5) return "take a slight right";
        if (angleDiff >= 67.5 && angleDiff < 112.5) return "take a right";
        if (angleDiff >= 112.5 && angleDiff < 157.5)
          return "take a sharp right";
        if (angleDiff >= 157.5 && angleDiff < 202.5) return "turn around";
        if (angleDiff >= 202.5 && angleDiff < 247.5) return "take a sharp left";
        if (angleDiff >= 247.5 && angleDiff < 292.5) return "take a left";
        if (angleDiff >= 292.5 && angleDiff < 337.5)
          return "take a slight left";

        return "continue";
      }

      function checkNodeArrival() {
        if (!isNavigating || !userPosition || currentRoute.length < 2) return;

        const now = Date.now();
        // Throttle announcements to prevent spamming
        if (now - lastAnnouncementTime < 5000) return;

        // Find the nearest node in the route
        let minDistance = Infinity;
        let nearestNode = null;
        let nodeIndex = -1;

        for (let i = 0; i < currentRoute.length; i++) {
          const nodeId = currentRoute[i];
          const node = CAMPUS_NODES[nodeId];
          const distance = calculateDistance(
            userPosition.lat,
            userPosition.lng,
            node.lat,
            node.lng
          );

          if (distance < minDistance) {
            minDistance = distance;
            nearestNode = node;
            nodeIndex = i;
          }
        }

        // Check if we're close enough to a node and haven't announced it recently
        if (
          minDistance < 15 &&
          nearestNode &&
          nearestNode.id !== lastAnnouncedNode &&
          !announcedNodes.has(nearestNode.id)
        ) {
          let announcement = `You are now at ${nearestNode.name}. `;

          // Get turn instruction if not at destination
          if (nodeIndex < currentRoute.length - 1) {
            const prevNode =
              nodeIndex > 0 ? CAMPUS_NODES[currentRoute[nodeIndex - 1]] : null;
            const nextNode = CAMPUS_NODES[currentRoute[nodeIndex + 1]];

            const turnDirection = getTurnDirection(
              prevNode,
              nearestNode,
              nextNode
            );
            announcement += `Now ${turnDirection}.`;
          }

          // Speak the announcement
          speak(announcement);

          // Update tracking
          announcedNodes.add(nearestNode.id);
          lastAnnouncedNode = nearestNode.id;
          lastAnnouncementTime = now;

          console.log("Announcement:", announcement);
        }
      }

      function renderCampusMap() {
        initLeafletMap();

        // Clear any previous layers
        campusMap.eachLayer((layer) => {
          if (layer instanceof L.Marker || layer instanceof L.Polyline) {
            campusMap.removeLayer(layer);
          }
        });

        // Add campus nodes as markers
        for (const [id, node] of Object.entries(CAMPUS_NODES)) {
          const marker = L.marker([node.lat, node.lng]).addTo(campusMap);
          marker.bindPopup(`${node.name}`);

          // Customize marker based on category
          const icon = L.divIcon({
            className: "map-node-icon",
            html: `<div style="background: #4CAF50; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>`,
            iconSize: [12, 12],
            iconAnchor: [6, 6],
          });
          marker.setIcon(icon);
        }

        // Add campus paths as polylines
        for (const path of CAMPUS_PATHS) {
          const fromNode = CAMPUS_NODES[path.from];
          const toNode = CAMPUS_NODES[path.to];

          if (!fromNode || !toNode) continue;

          const points = [
            [fromNode.lat, fromNode.lng],
            ...(path.waypoints || []),
            [toNode.lat, toNode.lng],
          ];

          const polyline = L.polyline(points, {
            color: "#FFC107",
            weight: 4,
          }).addTo(campusMap);
        }

        // Draw user position
        if (userPosition && userPosition.lat && userPosition.lng) {
          const userIcon = L.divIcon({
            className: "map-user-icon",
            html: `<div style="background: #2196F3; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 10px #2196f3;"></div>`,
            iconSize: [16, 16],
            iconAnchor: [8, 8],
          });

          const userMarker = L.marker([userPosition.lat, userPosition.lng], {
            icon: userIcon,
          }).addTo(campusMap);
        }

        // Draw destination if navigating
        if (isNavigating && selectedDestination) {
          const destNode = CAMPUS_NODES[DESTINATIONS[selectedDestination].node];
          if (destNode) {
            const destIcon = L.divIcon({
              className: "map-destination-icon",
              html: `<div style="background: #f44336; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 10px #f44336;"></div>`,
              iconSize: [16, 16],
              iconAnchor: [8, 8],
            });

            const destMarker = L.marker([destNode.lat, destNode.lng], {
              icon: destIcon,
            }).addTo(campusMap);
            destMarker
              .bindPopup(DESTINATIONS[selectedDestination].name)
              .openPopup();
          }
        }

        // Draw route if navigating
        if (isNavigating && currentRoute.length > 1) {
          const routePoints = [];
          for (let i = 0; i < currentRoute.length; i++) {
            const nodeId = currentRoute[i];
            const node = CAMPUS_NODES[nodeId];
            if (node) {
              routePoints.push([node.lat, node.lng]);
            }
          }

          if (routePoints.length > 1) {
            const routePolyline = L.polyline(routePoints, {
              color: "#4CAF50",
              weight: 6,
              dashArray: "5, 10",
            }).addTo(campusMap);
          }
        }

        // Fit map to show all points
        const points = Object.values(CAMPUS_NODES).map((node) => [
          node.lat,
          node.lng,
        ]);
        if (userPosition && userPosition.lat) {
          points.push([userPosition.lat, userPosition.lng]);
        }
        if (isNavigating && selectedDestination) {
          const destNode = CAMPUS_NODES[DESTINATIONS[selectedDestination].node];
          if (destNode) {
            points.push([destNode.lat, destNode.lng]);
          }
        }

        if (points.length > 0) {
          const bounds = L.latLngBounds(points);
          campusMap.fitBounds(bounds, { padding: [10, 10] });
        }
      }

      function toggleUiVisibility() {
        uiVisible = !uiVisible;
        console.log("Toggling UI, now visible:", uiVisible);

        if (uiVisible) {
          document.body.classList.add("ui-visible");
          elements.showUiBtn.textContent = "Hide UI";
          elements.statusPanel.classList.remove("hidden");
          elements.controlsPanel.classList.remove("hidden");
          // Only show stop button if currently navigating
          if (isNavigating) {
            elements.stopBtn.classList.remove("hidden");
          }
        } else {
          document.body.classList.remove("ui-visible");
          elements.showUiBtn.textContent = "Show UI";
          elements.statusPanel.classList.add("hidden");
          elements.controlsPanel.classList.add("hidden");
          elements.stopBtn.classList.add("hidden");
        }
      }

      async function startCamera() {
        try {
          // Try environment (rear) camera first
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: { ideal: "environment" },
              width: { ideal: 1280 },
              height: { ideal: 720 },
            },
          });

          elements.cameraFeed.srcObject = stream;
          cameraStream = stream;
          return stream;
        } catch (err) {
          console.warn("Environment camera failed, trying user camera...", err);

          // Fallback: Try front (user) camera
          try {
            const fallbackStream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: { ideal: "user" },
                width: { ideal: 1280 },
                height: { ideal: 720 },
              },
            });

            elements.cameraFeed.srcObject = fallbackStream;
            cameraStream = fallbackStream;
            return fallbackStream;
          } catch (error) {
            console.error("Camera error (both modes failed):", error);
            throw new Error(
              "Camera access failed. Please ensure no other app is using the camera and that permission is granted."
            );
          }
        }
      }

      async function fetchCampusData(instituteId) {
        try {
          const url = "https://ar-nav-system.onrender.com/api";
          // Fetch locations
          const locationsRes = await fetch(
            `${url}/institute/${instituteId}/locations`
          );
          const locations = await locationsRes.json();

          // Format locations
          locations.forEach((loc) => {
            CAMPUS_NODES[loc._id] = {
              lat: loc.coordinates.latitude,
              lng: loc.coordinates.longitude,
              name: loc.name,
              category: loc.category,
            };
          });

          // Fetch paths
          const pathsRes = await fetch(`${url}/institute/${instituteId}/paths`);
          const paths = await pathsRes.json();

          // Format paths
          CAMPUS_PATHS = paths.map((path) => ({
            from: path.from,
            to: path.to,
            distance: path.distance,
            waypoints: path.waypoints || [],
            accessibilityFriendly: path.accessibilityFriendly,
          }));

          // Create destinations
          locations.forEach((loc) => {
            DESTINATIONS[loc._id] = {
              node: loc._id,
              name: loc.name,
              icon: CATEGORY_ICONS[loc.category] || "üìç",
            };
          });

          return true;
        } catch (error) {
          console.error("Failed to fetch campus data:", error);
          throw new Error("Failed to load campus navigation data");
        }
      }

      function populateDestinationSelect() {
        const select = elements.destinationSelect;
        select.innerHTML = '<option value="">üéØ Select Destination</option>';

        // Group by category
        const categories = {};
        Object.entries(DESTINATIONS).forEach(([id, dest]) => {
          const category = CAMPUS_NODES[id].category;
          if (!categories[category]) categories[category] = [];
          categories[category].push({ id, ...dest });
        });

        // Add category groups to select
        Object.entries(categories).forEach(([category, items]) => {
          const group = document.createElement("optgroup");
          group.label = `${CATEGORY_ICONS[category] || "üìç"} ${
            category.charAt(0).toUpperCase() + category.slice(1)
          }`;

          items.forEach((dest) => {
            const option = document.createElement("option");
            option.value = dest.id;
            option.textContent = `${dest.icon} ${dest.name}`;
            group.appendChild(option);
          });

          select.appendChild(group);
        });
      }

      function startNavigation() {
        if (!selectedDestination || !userPosition) return;

        isNavigating = true;
        uiVisible = false; // Start with UI hidden
        announcedNodes = new Set();
        lastAnnouncedNode = null;
        lastAnnouncementTime = 0;

        // Update body classes
        document.body.classList.add("navigation-active");
        document.body.classList.remove("ui-visible");

        // Hide navigation button, show stop button and show UI button
        elements.navigateBtn.classList.add("hidden");
        elements.stopBtn.classList.remove("hidden");
        elements.showUiBtn.classList.remove("hidden");
        elements.showUiBtn.textContent = "Show UI";

        // Hide UI elements initially
        elements.statusPanel.classList.add("hidden");
        elements.controlsPanel.classList.add("hidden");

        currentRoute = calculateRoute();
        createPathArrows();

        updateNavigation();
      }

      function stopNavigation() {
        isNavigating = false;
        uiVisible = true;
        elements.navigateBtn.classList.remove("hidden");
        elements.stopBtn.classList.add("hidden");

        // Show UI elements again
        elements.statusPanel.classList.remove("hidden");
        elements.controlsPanel.classList.remove("hidden");

        clearPathArrows();

        elements.distanceDisplay.textContent = "Navigation stopped";
        elements.directionDisplay.textContent = "";
        elements.instructionDisplay.textContent =
          "Select a destination to navigate";

        document.body.classList.remove("navigation-active");
      }

      function updateNavigation() {
        if (!isNavigating || !userPosition || !selectedDestination) return;

        const destination = DESTINATIONS[selectedDestination];
        const destNode = CAMPUS_NODES[destination.node];

        if (!destNode) return;

        const distance = calculateDistance(
          userPosition.lat,
          userPosition.lng,
          destNode.lat,
          destNode.lng
        );

        const bearing = calculateBearing(
          userPosition.lat,
          userPosition.lng,
          destNode.lat,
          destNode.lng
        );

        // MODIFIED: Use relative directions instead of compass directions
        const direction = bearingToDirection(bearing, userPosition.heading);

        checkNodeArrival();

        if (distance < 10) {
          if (destNode.category === "building" && !arrivedAtBuilding) {
            arrivedAtBuilding = true;
            currentBuildingName = destNode.name;
            destinationNode = destNode;

            indoorPromptModal.style.display = "flex";
            return;
          }

          elements.distanceDisplay.textContent = "üéØ Arrived!";
          elements.directionDisplay.textContent =
            "You've reached your destination";
          elements.instructionDisplay.textContent = `Welcome to ${destination.name}`;
          setTimeout(() => stopNavigation(), 3000);
        } else if (distance < 50) {
          elements.distanceDisplay.textContent = `${Math.round(
            distance
          )}m away`;
          // MODIFIED: Updated text for relative directions
          elements.directionDisplay.textContent = `Almost there! ${direction}`;
          elements.instructionDisplay.textContent =
            "Look for the red AR arrows";
        } else {
          elements.distanceDisplay.textContent = `${Math.round(distance)}m to ${
            destination.icon
          } ${destination.name}`;
          // MODIFIED: Updated text for relative directions
          elements.directionDisplay.textContent = direction;
          elements.instructionDisplay.textContent =
            "Follow the AR arrows to your destination";
        }

        renderCampusMap();
      }

      function startGPSTracking() {
        const options = {
          enableHighAccuracy: true,
          maximumAge: 2000,
          timeout: 10000,
        };

        watchId = navigator.geolocation.watchPosition(
          handlePositionUpdate,
          handlePositionError,
          options
        );

        if (window.DeviceOrientationEvent) {
          window.addEventListener("deviceorientation", handleOrientationUpdate);
        } else {
          setInterval(() => {
            userHeading = (userHeading + 2) % 360;
            updateCompass();
          }, 100);
        }
      }

      function handlePositionUpdate(position) {
        const now = Date.now();
        if (now - lastUpdate < 1000) return;

        userPosition = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
          accuracy: position.coords.accuracy,
          heading: position.coords.heading || userHeading,
          speed: position.coords.speed || 0,
          timestamp: position.timestamp,
          altitude: position.coords.altitude || 0,
        };

        gpsAccuracy = position.coords.accuracy;
        lastUpdate = now;

        updateGPSStatus();
        updateDebugInfo();

        if (isNavigating) {
          currentRoute = calculateRoute();
          createPathArrows();
          updateNavigation();
        }

        renderCampusMap();
      }

      function handlePositionError(error) {
        console.error("GPS Error:", error);
        elements.gpsStatusText.textContent = `GPS Error: ${error.message}`;
        elements.statusDot.className = "status-dot status-poor";
        updateDebugInfo();
      }

      function handleOrientationUpdate(event) {
        if (event.alpha !== null) {
          userHeading = event.alpha;
          updateCompass();
          updateDebugInfo();
        }
      }

      function updateGPSStatus() {
        let statusText, statusClass;

        if (gpsAccuracy < 5) {
          statusText = `Excellent GPS (¬±${Math.round(gpsAccuracy)}m)`;
          statusClass = "status-excellent";
        } else if (gpsAccuracy < 10) {
          statusText = `Good GPS (¬±${Math.round(gpsAccuracy)}m)`;
          statusClass = "status-good";
        } else if (gpsAccuracy < 20) {
          statusText = `Moderate GPS (¬±${Math.round(gpsAccuracy)}m)`;
          statusClass = "status-moderate";
        } else {
          statusText = `Poor GPS (¬±${Math.round(gpsAccuracy)}m)`;
          statusClass = "status-poor";
        }

        elements.gpsStatusText.textContent = statusText;
        elements.statusDot.className = `status-dot ${statusClass}`;
      }

      function updateCompass() {
        if (elements.compassNeedle) {
          elements.compassNeedle.style.transform = `rotate(${userHeading}deg)`;
        }
      }

      function updateDebugInfo() {
        if (!elements.debugPanel) return;

        const debugContent = `
            <div>Lat: ${userPosition.lat.toFixed(6)}</div>
            <div>Lng: ${userPosition.lng.toFixed(6)}</div>
            <div>Accuracy: ${
              userPosition.accuracy
                ? userPosition.accuracy.toFixed(1) + "m"
                : "N/A"
            }</div>
            <div>Heading: ${userHeading.toFixed(1)}¬∞</div>
            <div>Speed: ${
              userPosition.speed
                ? (userPosition.speed * 3.6).toFixed(1) + " km/h"
                : "N/A"
            }</div>
            <div>Destination: ${selectedDestination || "None"}</div>
            <div>Navigation: ${isNavigating ? "Active" : "Inactive"}</div>
        `;

        elements.debugInfo.innerHTML = debugContent;
      }

      async function requestLocationPermission() {
        return new Promise((resolve, reject) => {
          if (!navigator.geolocation) {
            simulationMode = true;
            elements.permissionStatus.textContent =
              "‚ö†Ô∏è Geolocation not supported. Using simulation mode.";
            resolve();
            return;
          }

          // FIX: Use a timeout to prevent infinite waiting
          const timeoutId = setTimeout(() => {
            simulationMode = true;
            elements.permissionStatus.textContent =
              "‚ö†Ô∏è Location request timed out. Using simulation mode.";
            resolve();
          }, 10000); // Timeout after 10 seconds

          navigator.geolocation.getCurrentPosition(
            (position) => {
              clearTimeout(timeoutId);
              elements.permissionStatus.textContent =
                "‚úÖ Location access granted";
              resolve(position);
            },
            (error) => {
              clearTimeout(timeoutId);
              const messages = {
                [error.PERMISSION_DENIED]: "Location permission denied",
                [error.POSITION_UNAVAILABLE]: "Location unavailable",
                [error.TIMEOUT]: "Location request timeout",
              };
              simulationMode = true;
              elements.permissionStatus.textContent = `‚ö†Ô∏è ${
                messages[error.code] || "Location error"
              }. Using simulation mode.`;
              resolve();
            },
            { enableHighAccuracy: true, timeout: 15000 }
          );
        });
      }

      function setupEventListeners() {
        elements.mapToggle.addEventListener("click", () => {
          elements.mapOverlay.classList.toggle("hidden");
          elements.mapToggle.textContent =
            elements.mapOverlay.classList.contains("hidden")
              ? "Show Campus Map"
              : "Hide Campus Map";

          // When map is shown, invalidate Leaflet map size
          if (!elements.mapOverlay.classList.contains("hidden") && campusMap) {
            setTimeout(() => campusMap.invalidateSize(), 100);
          }
        });

        elements.destinationSelect.addEventListener("change", (e) => {
          selectedDestination = e.target.value;
          elements.navigateBtn.disabled = !selectedDestination;

          if (selectedDestination) {
            const dest = DESTINATIONS[selectedDestination];
            elements.distanceDisplay.textContent = `Ready to navigate to ${dest.icon} ${dest.name}`;
          } else {
            elements.distanceDisplay.textContent = "Select destination";
          }
        });

        elements.navigateBtn.addEventListener("click", startNavigation);
        elements.stopBtn.addEventListener("click", stopNavigation);

        elements.calibrateBtn.addEventListener("click", () => {
          elements.instructionDisplay.textContent =
            "Move your phone in a figure-8 pattern for 5 seconds...";

          setTimeout(() => {
            compassCalibrated = true;
            elements.instructionDisplay.textContent =
              "Compass calibrated! Navigation accuracy improved.";
          }, 5000);
        });

        elements.showUiBtn.addEventListener("click", toggleUiVisibility);

        elements.indoorYes.addEventListener("click", () => {
          // Get instituteId from URL
          const urlParams = new URLSearchParams(window.location.search);
          const instituteId = urlParams.get("instituteId");

          // Redirect to indoor navigation for this building
          window.location.href = `indoor.html?building=${encodeURIComponent(
            currentBuildingName
          )}&instituteId=${instituteId}`;
        });

        elements.indoorNo.addEventListener("click", () => {
          indoorPromptModal.style.display = "none";

          // Continue with normal arrival handling
          elements.distanceDisplay.textContent = "üéØ Arrived!";
          elements.directionDisplay.textContent =
            "You've reached your destination";
          elements.instructionDisplay.textContent = `Welcome to ${destination.name}`;
          setTimeout(() => stopNavigation(), 3000);
        });

        // Handle window resize for Leaflet map
        window.addEventListener("resize", () => {
          if (campusMap && !elements.mapOverlay.classList.contains("hidden")) {
            setTimeout(() => campusMap.invalidateSize(), 100);
          }
        });
      }

      async function initialize() {
        try {
          elements.loadingStatus.textContent = "Initializing AR navigation...";

          // Get institute ID from localStorage
          const instituteId = localStorage.getItem("instituteId") || "demo";
          elements.loadingStatus.textContent = "Loading campus data...";
          await fetchCampusData(instituteId);

          elements.loadingStatus.textContent = "Requesting location access...";
          await requestLocationPermission();

          elements.loadingStatus.textContent = "Requesting camera access...";
          await startCamera();

          startGPSTracking();
          setupEventListeners();
          populateDestinationSelect();

          setTimeout(() => {
            elements.loader.style.opacity = "0";

            setTimeout(() => {
              elements.loader.classList.add("hidden");

              if (uiVisible) {
                elements.statusPanel.classList.remove("hidden");
                elements.controlsPanel.classList.remove("hidden");
                elements.stopBtn.classList.remove("hidden");
              } else {
                elements.statusPanel.classList.add("hidden");
                elements.controlsPanel.classList.add("hidden");
                elements.stopBtn.classList.add("hidden");
              }

              elements.compass.classList.remove("hidden");
              elements.debugPanel.style.display = "block";
              renderCampusMap();
            }, 500);
          }, 1000);
        } catch (error) {
          console.error("Initialization failed:", error);
          elements.loadingStatus.textContent = `Error: ${error.message}`;

          if (error.message.includes("Camera")) {
            elements.permissionStatus.innerHTML = `
    Camera access required!<br>
    <button id="retry-camera" style="margin-top:10px; padding:5px 10px;">
      Retry Camera Access
    </button>
  `;
            document
              .getElementById("retry-camera")
              .addEventListener("click", initialize);
          } else if (error.message.includes("Location")) {
            elements.permissionStatus.innerHTML = `
    Location access required!<br>
    <button id="retry-location" style="margin-top:10px; padding:5px 10px;">
      Retry Location Access
    </button>
  `;
            document
              .getElementById("retry-location")
              .addEventListener("click", initialize);
          } else {
            elements.permissionStatus.innerHTML = `
    ${error.message}<br>
    <button id="retry-init" style="margin-top:10px; padding:5px 10px;">
      Try Again
    </button>
  `;
            document
              .getElementById("retry-init")
              .addEventListener("click", initialize);
          }
        }
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initialize);
      } else {
        initialize();
      }

      window.addEventListener("beforeunload", () => {
        if (watchId) {
          navigator.geolocation.clearWatch(watchId);
        }
        if (cameraStream) {
          cameraStream.getTracks().forEach((track) => track.stop());
        }
      });
    </script>
  </body>
</html>
